//
//  CreateDirectionViewController.swift
//  OneDirection
//
//  Created by Ashish Nautiyal on 3/11/19.
//  Copyright (c) 2019 Ashish  Nautiyal. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation
import MapKit
protocol CreateDirectionDisplayLogic: class
{
}

class CreateDirectionViewController: UIViewController, CreateDirectionDisplayLogic
{
    //MARK: Outlets
    @IBOutlet weak var mapVIew: MKMapView!
    @IBOutlet weak var startingPointText: UITextField!
    @IBOutlet weak var endPointText: UITextField!
    
    //MARK: Variables
    let locationManager = CLLocationManager()
    var isStartPoint: Bool = true
    var spinner: UIActivityIndicatorView?
    var startingPoint: CLPlacemark?
    var endPoint: CLPlacemark?
    var response: MKDirectionsResponse?
    var interactor: CreateDirectionBusinessLogic?
    var router: (NSObjectProtocol & CreateDirectionRoutingLogic & CreateDirectionDataPassing)?
    
    // MARK: Object lifecycle
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        spinner = SpinnerView.showLoader(view: view)
        configureToolbarItems()
        startingPointText.addTarget(self, action: #selector(textFieldTapped), for: UIControlEvents.touchDown)
        endPointText.addTarget(self, action: #selector(textFieldTapped), for: UIControlEvents.touchDown)
        mapVIew.delegate = self
        mapVIew.mapType = .standard
        mapVIew.isZoomEnabled = true
        mapVIew.isScrollEnabled = true
        setupLocationManager()
        
    }
    override func viewWillAppear(_ animated: Bool) {
        if let startingPoint = startingPoint {
            startingPointText.text = startingPoint.locality == nil ?startingPoint.name :startingPoint.locality
        }
        if let endPoint = endPoint {
            
            endPointText.text = endPoint.locality == nil ? endPoint.name : endPoint.locality
        }
    }
    
    // MARK: Routing
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
        router?.dataStore?.isStartPoint = isStartPoint
        router?.routToFindLocation(segue: segue)
    }
    
    // MARK: Setup
    private func setup()
    {
        let viewController = self
        let interactor = CreateDirectionInteractor()
        let presenter = CreateDirectionPresenter()
        let router = CreateDirectionRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    
    
    // MARK: IBActions
    @objc func textFieldTapped(textField: UITextField) {
        isStartPoint = textField == startingPointText
        self.performSegue(withIdentifier: "findAddressSegue", sender: nil)
    }
    
    @IBAction func swapLocations(_ sender: Any) {
        let tmpPoint = startingPoint
        startingPoint = endPoint
        endPoint = tmpPoint
        if let startingPoint = startingPoint {
            startingPointText.text = startingPoint.locality == nil ?startingPoint.name :startingPoint.locality
        }
        else {
           startingPointText.text = nil
        }
        if let endPoint = endPoint {
            endPointText.text = endPoint.locality == nil ? endPoint.name : endPoint.locality
        }
        else {
            endPointText.text = nil
        }
    }
    
    @IBAction func findRoute(_ sender: Any) {
        if startingPoint == nil {
            AlertController.showAlert("Enter starting point", message: "Starting point caould not be empty")
            return
        }
        if endPoint == nil {
            AlertController.showAlert("Enter destination point", message: "Destination point caould not be empty")
            return
        }
        let request = MKDirectionsRequest()
        let mkPlacemark = MKPlacemark(coordinate: (endPoint?.location?.coordinate)!)
        let mkPlacemark2 = MKPlacemark(coordinate: (startingPoint?.location?.coordinate)!)
        request.source = MKMapItem(placemark: mkPlacemark)
        request.destination = MKMapItem(placemark: mkPlacemark2)
        request.requestsAlternateRoutes = false
        let directions = MKDirections(request: request)
        spinner?.startAnimating()
        directions.calculate(completionHandler: {(response, error) in
            self.spinner?.stopAnimating()
            if error != nil {
                AlertController.showAlert("Route not found", message: error?.localizedDescription ?? "Try another location")
            } else {
                self.showRoute(response!)
            }
        })
    }
    
    //MARK: Private methods
    func setupLocationManager() {
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
    }
    func showRoute(_ response: MKDirectionsResponse) {
        self.response = response
        for route in response.routes {
          mapVIew.add(route.polyline,
                        level: MKOverlayLevel.aboveRoads)
        }
        navigationController?.setToolbarHidden(response.routes.count < 1 , animated: true)
    }
}
// -------------------------------------------------------------------------
// MARK: Map Delegate
extension CreateDirectionViewController : MKMapViewDelegate {
    @IBAction func setLocation(_ sender: Any) {
        locationManager.requestWhenInUseAuthorization()
        if (CLLocationManager.authorizationStatus() == CLAuthorizationStatus.authorizedWhenInUse ||
            CLLocationManager.authorizationStatus() == CLAuthorizationStatus.authorizedAlways){
            guard let currentLocation = locationManager.location else {
                return
            }
            spinner?.startAnimating()
            startingPointText.text = "My Location"
            let loc: CLLocation = CLLocation(latitude: currentLocation.coordinate.latitude, longitude: currentLocation.coordinate.longitude)
            let geoCoder = CLGeocoder()
            geoCoder.reverseGeocodeLocation(loc, completionHandler:
                {(placemarks, error) in
                    self.spinner?.stopAnimating()
                    if let error = error
                    {
                        AlertController.showAlert("Unable to getLocation", message: error.localizedDescription)
                    }
                    
                    if (placemarks?.count)! > 0 {
                        self.startingPoint = placemarks?[0]
                        
                        self.startingPointText.text = self.startingPoint?.locality == nil ?self.startingPoint?.name : self.startingPoint?.locality
                    }
            })
        }
        
    }
    
    
    
    func mapView(_ mapView: MKMapView, rendererFor
        overlay: MKOverlay) -> MKOverlayRenderer {
        let renderer = MKPolylineRenderer(overlay: overlay)
        renderer.strokeColor = UIColor.blue
        renderer.lineWidth = 1.0
        return renderer
    }
    
    
    // -------------------------------------------------------------------------
    // MARK: Toolbar
    func configureToolbarItems() {
        toolbarItems = makeToolbarItems()
    }
    
    /// Returns an array of toolbar items. Used to configure the view controller's
    /// `toolbarItems' property
    func makeToolbarItems() -> [UIBarButtonItem] {
        let space = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)
        let collection = UIBarButtonItem(title: "Post Trip", style: .plain, target: self, action: #selector(createTrip(sender:)) )
        return [space,collection,space]
    }
    
    @objc func createTrip(sender: Any){
        guard let _ = startingPoint else {
            AlertController.showAlert("Request Failed",message: "Please enter starting point" )
            return
        }
        guard let _ = endPoint else {
            AlertController.showAlert("Request Failed",message: "Please enter destination point" )
            return
        }
        self.performSegue(withIdentifier: "createTripSegue", sender: nil)
    }
    
    @IBAction func cancel(_ sender: Any) {
        self.dismiss(animated: true, completion: nil)
    }
    
    
}




