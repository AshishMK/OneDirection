//
//  MainWorker.swift
//  OneDirection
//
//  Created by Ashish Nautiyal on 3/8/19.
//  Copyright (c) 2019 Ashish  Nautiyal. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Foundation

class MainWorker
{
    typealias Parameters = [String: String]
    enum Endpoints {
        static let baseURLParse = "http://97.74.4.59:"
        case getOTP (String, String)
        case verifyOTP
        case createTripOD
        case getTrips
        case getMyTrips
        case getTripRequestOD
        case getTripRequestTripOD(String)
        case bookTicket
        case deleteTicket
        case deleteTrip
        case getComments(String)
        case addComment
        case deleteComment
        case getCommentsByUserId
        case getTrip
        
        var stringValue : String {
            switch self {
            case .getOTP(let phone,let name):
                return Endpoints.baseURLParse + "3000/getOTPOD/" + phone + "/" + (name.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")
            case .verifyOTP:
                return Endpoints.baseURLParse + "3040/verifyOTPOD"
            case .getTrip:
                return Endpoints.baseURLParse + "3040/getTripOD"
            case .createTripOD:
                return Endpoints.baseURLParse + "3040/createTripOD"
            case .getTrips:
                return Endpoints.baseURLParse + "3000/getTripsOD/\(UserManager.shared.getUserId() ?? "")/\(UserManager.shared.getUserlat())/\(UserManager.shared.getUserlng())"
            case .getTripRequestOD:
                return Endpoints.baseURLParse + "3000/getTripRequestOD/\(UserManager.shared.getUserId() ?? "")"
            case .getTripRequestTripOD(let trip_id):
                return Endpoints.baseURLParse + "3000/getTripRequestTripOD/\(trip_id)"
            case .getMyTrips:
                return Endpoints.baseURLParse + "3000/getTripsMyOD/\(UserManager.shared.getUserId() ?? "")"
            case .bookTicket:
                return Endpoints.baseURLParse + "3040/RequestsOD"
            case .deleteTicket:
                return Endpoints.baseURLParse + "3040/deleteRequestOD"
            case .deleteTrip:
                return Endpoints.baseURLParse + "3040/deleteTripOD"
            case .getComments(let trip_id):
                return Endpoints.baseURLParse + "3000/getTripCommentsOD/\(trip_id)"
            case .addComment:
                return Endpoints.baseURLParse + "3040/addCommentOD"
            case .deleteComment:
                return Endpoints.baseURLParse + "3040/deleteCommentOD"
            case .getCommentsByUserId:
                return Endpoints.baseURLParse + "3000/getCommentByUser/\(UserManager.shared.getUserId() ?? "")"
            }
        }
        var url: URL {
            return URL(string: stringValue)!
        }
    }
    
    class func taskForGETRequest<ResponseType: Decodable>(url: URL, responseType: ResponseType.Type, completion: @escaping (ResponseType?, Error?) -> Void)-> URLSessionTask{
        let request = URLRequest(url: url)
        print("url \(url)")
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            guard let data = data else {
                DispatchQueue.main.async {
                    completion(nil, error)
                }
                return
            }
            print(String(data: data, encoding: .utf8)!)
            let decoder = JSONDecoder()
            do {
                let responseObject = try decoder.decode(ResponseType.self, from: data)
                DispatchQueue.main.async {
                    completion(responseObject, nil)
                }
            }
                //         catch let DecodingError.dataCorrupted(context) {
                //            print(context)
                //        } catch let DecodingError.keyNotFound(key, context) {
                //            print("Key '\(key)' not found:", context.debugDescription)
                //            print("codingPath:", context.codingPath)
                //        } catch let DecodingError.valueNotFound(value, context) {
                //            print("Value '\(value)' not found:", context.debugDescription)
                //            print("codingPath:", context.codingPath)
                //        } catch let DecodingError.typeMismatch(type, context)  {
                //            print("Type '\(type)' mismatch:", context.debugDescription)
                //            print("codingPath:", context.codingPath)
                //        } catch {
                //            print("error: ", error)
                //        }
                
                
                
            catch {
                do{
                    let errorResponse = try decoder.decode(ErrorResponse.self, from: data)
                    DispatchQueue.main.async {
                        completion(nil,errorResponse)
                    }
                }
                catch{
                    DispatchQueue.main.async {
                        completion(nil, error)
                    }
                }
            }
        }
        task.resume()
        return task
    }
    
    
    class func taskForPOSTRequest< ResponseType: Decodable>(url: URL, responseType: ResponseType.Type, parameters: Parameters, completion: @escaping (ResponseType?, Error?) -> Void){
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        
        let boundary = generateBoundary()
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        
        request.httpBody = createDataBody(withParameters: parameters,media: [],
                                          boundary: boundary)
        let task = URLSession.shared.dataTask(with: request){
            data,response,error
            in
            print(String(data: data!, encoding: .utf8)!)
            guard let data = data else{
                
                DispatchQueue.main.async {
                    completion(nil,error)
                }
                return
            }
            
            let decoder = JSONDecoder()
            do{
                
                let requestTokenResponse = try decoder.decode(ResponseType.self, from: data)
                
                DispatchQueue.main.async {
                    completion(requestTokenResponse,nil)
                }
            }catch{
                
                do{
                    let errorResponse = try decoder.decode(ErrorResponse.self, from: data)
                    DispatchQueue.main.async {
                        completion(nil,errorResponse)
                    }
                }
                catch{
                    DispatchQueue.main.async {
                        completion(nil, error)
                    }
                }
            }
        }
        task.resume()
    }
    
    class func generateBoundary() -> String {
        return "Boundary-\(NSUUID().uuidString)"
    }
    
    class func createDataBody(withParameters params: Parameters?, media: [MediaPostData]?, boundary: String) -> Data {
        
        let lineBreak = "\r\n"
        var body = Data()
        
        if let parameters = params {
            for (key, value) in parameters {
                body.append("--\(boundary + lineBreak)")
                body.append("Content-Disposition: form-data; name=\"\(key)\"\(lineBreak + lineBreak)")
                body.append("\(value + lineBreak)")
            }
        }
        
        if let media = media {
            for photo in media {
                body.append("--\(boundary + lineBreak)")
                body.append("Content-Disposition: form-data; name=\"\(photo.key)\"; filename=\"\(photo.filename)\"\(lineBreak)")
                body.append("Content-Type: \(photo.mimeType + lineBreak + lineBreak)")
                body.append(photo.data)
                body.append(lineBreak)
            }
        }
        
        body.append("--\(boundary)--\(lineBreak)")
        
        return body
    }
}

extension Data {
    mutating func append(_ string: String) {
        if let data = string.data(using: .utf8) {
            append(data)
        }
    }
}

